TASK: Prepare FULL-SITE localization scaffolding for 30 locales (EVERYTHING) — NO translation, NO AI generation

GOAL:
Make the ENTIRE product fully localization-ready across 30 locales by ensuring:
1) Every user-visible string is externalized into i18n keys
2) English is the single source of truth
3) All 29 other locales mirror the English key structure exactly
4) The app never shows mixed-language UI due to missing keys (fail-visible remains active)

ABSOLUTE SCOPE (NO EXCEPTIONS):
- Public site (home, destinations, attractions, guides, news, static pages)
- All public components (cards, filters, search, pagination, sort, chips, tabs, empty states)
- All navigation (header, footer, mobile menu)
- All CTAs, badges, tooltips, banners, cookie consent
- All form labels + validation messages
- All accessibility strings: aria-label, aria-describedby, alt, title, placeholder
- All system UI copy: loading states, error states, “not found”, permission messages
- All SEO/meta UI strings that are template-driven (NOT the large editorial content)
- All admin/CMS UI too (unless explicitly excluded) — if it is user-visible in the product, it goes in i18n.

CRITICAL CONSTRAINTS:
- DO NOT translate into other languages.
- DO NOT rewrite copy.
- DO NOT generate new content.
- DO NOT call Octypo / external AI providers.
- DO NOT add NEEDS_TRANSLATION / MISSING markers into values.
- Keep fail-visible mode: missing keys must still be detectable during development, but our goal is to reach ZERO missing keys.

SINGLE SOURCE OF TRUTH:
- client/src/locales/en/common.json is canonical.
- If you already use multiple namespaces/files, keep them, but ensure English source-of-truth is complete and other locales mirror them.

DELIVERABLES:
A) 100% Extraction:
- Zero user-visible hardcoded strings remain anywhere in client code:
  - JSX text nodes
  - aria-label / alt / title / placeholder
  - toast messages
  - validation errors
  - dropdown options
  - table column headers
  - empty state copy
  - “coming soon”, “pending generation”, etc.
- Everything uses t('...') keys.

B) 30-locale Files Created & Mirrored:
- For each locale in LOCALE_PREFIXES (30 total), ensure:
  client/src/locales/{locale}/common.json exists
- Copy exact key structure from en/common.json to every locale.
- Values in non-English locales should be EXACTLY the English value for now (temporary).
  (We will later replace values with Claude Code translation. For now we just need parity.)

C) Build-Time Enforcement:
- Ensure parity check runs in build and CI:
  - If any locale is missing a key, build fails.
- Add/confirm scripts:
  - npx tsx scripts/check-translation-parity.ts
  - npx tsx scripts/scan-hardcoded-strings.ts (must cover public + admin)
- Make npm run build run parity check first (unless SKIP_PARITY_CHECK=true).

D) Routing & Locale Default:
- Root path "/" MUST serve English by default without user needing to click /en.
  - Implement "/" → "/en" redirect (server-side if SSR; client-side only if absolutely necessary).
- All locale-prefixed routes work consistently: /en/*, /ar/*, etc.

E) RTL + Direction Correctness (PREP WORK NOW):
- RTL locales: ar, he, fa, ur
- Ensure:
  - documentElement lang/dir updates correctly per locale
  - UI direction-dependent icons/chevrons/arrows are logically flipped using isRTL
  - No hardcoded left/right assumptions in CSS (use logical properties or conditional classes)

F) Content Categories — What to Externalize Now vs Later:
We are preparing everything. However, we must differentiate:
1) UI STRINGS (MUST externalize now):
   - labels, headings, buttons, UI descriptions, notices, system messages, category labels
2) CONTENT DATA (still must be localizable-ready):
   - attractions descriptions, guide bodies, long editorial/legal text, dynamic CMS blocks
   - DO NOT translate/generate these now
   - BUT you MUST ensure the system can display per-locale content fields later:
     - Add locale-aware fields or mapping points if missing
     - Add placeholders in UI that are locale-safe (e.g., “Content pending” localized via keys)

IMPORTANT IMPLEMENTATION RULES:
1) Key naming convention (strict):
- Use stable, semantic keys:
  nav.destinations, nav.attractions, nav.guides, nav.news
  home.hero.title, home.hero.subtitle, home.cta.exploreDestinations
  attractions.filters.sortBy, attractions.empty.title, etc.
- Never use raw text as key.

2) No duplicate strings:
- If the same label is used in multiple places, reuse the same key.

3) No partial extraction:
- If a component renders user-visible copy, it must be fully i18n’d.

4) Accessibility is not optional:
- alt/aria/title/placeholder are all i18n keys.

5) Do not break tests:
- Update E2E selectors if they relied on raw text.
- Prefer data-testid for tests.

STEP-BY-STEP EXECUTION PLAN (DO IT IN THIS ORDER):
1) Inventory:
- Run scanner / grep for:
  - JSX text nodes
  - aria-label=, alt=, title=, placeholder=
  - toast(, alert(, error messages
2) Extract to en/common.json:
- Add missing keys and replace in code with t()
3) Mirror to 29 locales:
- Create/overwrite locale common.json with exact English structure & values
4) Run parity check:
- Must pass for all locales
5) Run E2E smoke:
- /en home loads with zero missing markers
- /ar home loads RTL
- /he home loads RTL
6) Commit summary:
- Provide list of files changed, scripts added/updated, and confirmation:
  - “hardcoded strings = 0 (scanner)”
  - “parity = pass (30 locales)”
  - “E2E smoke = pass”

OUTPUT REQUIRED FROM YOU AFTER COMPLETION:
- Exact list of:
  - New scripts (paths)
  - Updated build pipeline steps
  - Count of extracted strings
  - Confirmation that ALL locale files exist and match keys
  - Confirmation that "/" defaults to /en and locale routes work

DO NOT ASK ME QUESTIONS.
DO NOT SAY “WAIT FOR QUOTA”.
JUST IMPLEMENT.

START NOW.