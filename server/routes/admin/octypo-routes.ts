/**
 * Octypo Admin Routes
 *
 * Admin dashboard API for managing the AI content generation system
 */

import { Router, type Request, type Response } from "express";
import { db } from "../../db";
import { tiqetsAttractions, contents, workflowInstances, aiWriters } from "@shared/schema";
import { eq, isNull, isNotNull, sql, desc, and, gte } from "drizzle-orm";
import { log } from "../../lib/logger";
import {
  AgentRegistry,
  initializeWriterAgents,
  initializeValidatorAgents,
  generateAttractionWithOctypo,
  getOctypoOrchestrator,
} from "../../octypo";
import { octypoState } from "../../octypo/state";
import { EngineRegistry } from "../../services/engine-registry";
import { getQueueStats } from "../../ai/request-queue";
import { jobQueue } from "../../job-queue";
// manuallyProcessRSSJob removed â€” use Gatekeeper pipeline instead
import {
  startRSSScheduler,
  stopRSSScheduler,
  updateRSSSchedulerConfig,
  getRSSSchedulerStatus,
  manualTrigger as triggerRSSScheduler,
  getSchedulerStats,
} from "../../octypo/rss-scheduler";
import { rssReader } from "../../octypo/rss-reader";

const router = Router();

let initialized = false;

function ensureInitialized() {
  if (!initialized) {
    initializeWriterAgents();
    initializeValidatorAgents();
    initialized = true;
  }
}

interface WriterAgentInfo {
  id: string;
  name: string;
  specialty: string;
  expertise: string[];
  contentCount: number;
}

interface ValidatorAgentInfo {
  id: string;
  name: string;
  specialty: string;
}

interface OctypoStats {
  totalAttractions: number;
  pendingContent: number;
  generatedContent: number;
  writerAgentCount: number;
  validatorAgentCount: number;
  avgQualityScore: number;
}

/**
 * GET /api/octypo/stats
 * Returns system stats for the dashboard - content generated by Octypo (NOT attractions)
 */
router.get("/stats", async (_req: Request, res: Response) => {
  try {
    ensureInitialized();

    // Query the contents table for Octypo-generated content stats
    const [contentStats, avgScoreResult] = await Promise.all([
      db
        .execute(
          sql`
        SELECT
          COUNT(*)::int as total_content,
          COUNT(CASE WHEN status = 'draft' OR status = 'in_review' THEN 1 END)::int as pending_content,
          COUNT(CASE WHEN status = 'published' OR status = 'approved' THEN 1 END)::int as generated_content
        FROM contents
      `
        )
        .then(r => r.rows[0] as any),

      db
        .execute(
          sql`
        SELECT COALESCE(AVG(seo_score), 0)::numeric(5,2) as avg_score
        FROM contents
        WHERE seo_score IS NOT NULL
      `
        )
        .then(r => Number.parseFloat(String((r.rows[0] as any)?.avg_score ?? 0))),
    ]);

    const writers = AgentRegistry.getAllWriters();
    const validators = AgentRegistry.getAllValidators();

    const stats: OctypoStats = {
      totalAttractions: 0, // Not relevant for Octypo
      pendingContent: Number.parseInt(contentStats?.pending_content) || 0,
      generatedContent: Number.parseInt(contentStats?.total_content) || 0,
      writerAgentCount: writers.length,
      validatorAgentCount: validators.length,
      avgQualityScore: avgScoreResult,
    };

    res.json(stats);
  } catch (error) {
    log.error("[Octypo] Failed to get stats", error);
    res.status(500).json({ error: "Failed to retrieve stats" });
  }
});

/**
 * GET /api/octypo/agents/writers
 * Returns all writer agents with their specialties and expertise
 */
router.get("/agents/writers", async (_req: Request, res: Response) => {
  try {
    ensureInitialized();

    const writers = AgentRegistry.getAllWriters();

    const writerInfos: WriterAgentInfo[] = writers.map(writer => ({
      id: writer.id,
      name: writer.name,
      specialty: writer.specialty,
      expertise: (writer as any).persona?.expertise || [],
      contentCount: 0,
    }));

    res.json(writerInfos);
  } catch (error) {
    log.error("[Octypo] Failed to get writers", error);
    res.status(500).json({ error: "Failed to retrieve writers" });
  }
});

/**
 * GET /api/octypo/agents/validators
 * Returns all validator agents
 */
router.get("/agents/validators", async (_req: Request, res: Response) => {
  try {
    ensureInitialized();

    const validators = AgentRegistry.getAllValidators();

    const validatorInfos: ValidatorAgentInfo[] = validators.map(validator => ({
      id: validator.id,
      name: validator.name,
      specialty: validator.specialty,
    }));

    res.json(validatorInfos);
  } catch (error) {
    log.error("[Octypo] Failed to get validators", error);
    res.status(500).json({ error: "Failed to retrieve validators" });
  }
});

/**
 * GET /api/octypo/queue
 * Returns attractions pending content generation
 */
router.get("/queue", async (req: Request, res: Response) => {
  try {
    const limit = Math.min(Number.parseInt(req.query.limit as string) || 100, 500);
    const offset = Number.parseInt(req.query.offset as string) || 0;

    const countResult = await db.execute(sql`
      SELECT count(*)::int as count 
      FROM tiqets_attractions 
      WHERE ai_content IS NULL
    `);
    const total = (countResult.rows[0] as any)?.count ?? 0;

    let attractions: any[] = [];
    if (total > 0) {
      attractions = await db
        .select({
          id: tiqetsAttractions.id,
          title: tiqetsAttractions.title,
          cityName: tiqetsAttractions.cityName,
          primaryCategory: tiqetsAttractions.primaryCategory,
          priceFrom: tiqetsAttractions.priceUsd,
          rating: tiqetsAttractions.tiqetsRating,
          reviewCount: tiqetsAttractions.tiqetsReviewCount,
        })
        .from(tiqetsAttractions)
        .where(isNull(tiqetsAttractions.aiContent))
        .orderBy(desc(tiqetsAttractions.tiqetsReviewCount))
        .limit(limit)
        .offset(offset);
    }

    res.json({
      queue: attractions,
      total,
      limit,
      offset,
    });
  } catch (error) {
    log.error("[Octypo] Failed to get queue", error);
    res.status(500).json({ error: "Failed to retrieve queue" });
  }
});

/**
 * POST /api/octypo/generate/:attractionId
 * Triggers content generation for a single attraction
 */
router.post("/generate/:attractionId", async (req: Request, res: Response) => {
  try {
    ensureInitialized();

    const attractionId = req.params.attractionId;
    if (!attractionId) {
      return res.status(400).json({ error: "Invalid attraction ID" });
    }

    const [attraction] = await db
      .select()
      .from(tiqetsAttractions)
      .where(eq(tiqetsAttractions.id, attractionId))
      .limit(1);

    if (!attraction) {
      return res.status(404).json({ error: "Attraction not found" });
    }

    const attractionData = {
      id: Number.parseInt(String(attraction.id), 10) || Date.now(),
      title: attraction.title || "",
      cityName: attraction.cityName || "",
      venueName: attraction.venueName || undefined,
      duration: attraction.duration || undefined,
      primaryCategory: attraction.primaryCategory || undefined,
      secondaryCategories: attraction.secondaryCategories || undefined,
      languages: attraction.languages || undefined,
      wheelchairAccess: attraction.wheelchairAccess || undefined,
      tiqetsDescription: attraction.tiqetsDescription || undefined,
      tiqetsHighlights: attraction.tiqetsHighlights || undefined,
      priceFrom: attraction.priceUsd ? Number.parseFloat(String(attraction.priceUsd)) : undefined,
      rating: attraction.tiqetsRating
        ? Number.parseFloat(String(attraction.tiqetsRating))
        : undefined,
      reviewCount: attraction.tiqetsReviewCount || undefined,
      address: attraction.venueAddress || undefined,
      coordinates:
        attraction.latitude && attraction.longitude
          ? {
              lat: Number.parseFloat(String(attraction.latitude)),
              lng: Number.parseFloat(String(attraction.longitude)),
            }
          : undefined,
    };

    log.info(
      `[Octypo] Starting content generation for attraction ${attractionId}: ${attraction.title}`
    );

    const result = await generateAttractionWithOctypo(attractionData);

    if (result.success && result.content) {
      await db
        .update(tiqetsAttractions)
        .set({
          aiContent: {
            ...result.content,
            qualityScore: result.qualityScore?.overallScore || 0,
            quality108: result.quality108 || null,
            writerUsed: result.writerId,
            generatedAt: new Date().toISOString(),
            processingTimeMs: result.generationTimeMs,
          },
          contentGenerationStatus: "completed",
        } as any)
        .where(eq(tiqetsAttractions.id, attractionId as any));

      log.info(`[Octypo] Content generation completed for attraction ${attractionId}`);
    } else {
      await db
        .update(tiqetsAttractions)
        .set({
          contentGenerationStatus: "failed",
        } as any)
        .where(eq(tiqetsAttractions.id, attractionId));
    }

    res.json({
      success: result.success,
      attractionId,
      qualityScore: result.qualityScore?.overallScore,
      quality108: result.quality108,
      writerUsed: result.writerUsed,
      processingTimeMs: result.processingTimeMs,
      errors: result.errors,
    });
  } catch (error) {
    log.error("[Octypo] Generation failed", error);
    res.status(500).json({
      error: "Content generation failed",
      message: error instanceof Error ? error.message : "Unknown error",
    });
  }
});

/**
 * GET /api/octypo/jobs/recent
 * Returns recent content generation jobs
 */
router.get("/jobs/recent", async (req: Request, res: Response) => {
  try {
    const limit = Math.min(Number.parseInt(req.query.limit as string) || 50, 100);

    const recentJobs = await db
      .select({
        id: tiqetsAttractions.id,
        title: tiqetsAttractions.title,
        cityName: tiqetsAttractions.cityName,
        status: tiqetsAttractions.contentGenerationStatus,
        aiContent: tiqetsAttractions.aiContent,
      })
      .from(tiqetsAttractions)
      .where(isNotNull(tiqetsAttractions.contentGenerationStatus))
      .orderBy(desc(tiqetsAttractions.id))
      .limit(limit);

    const jobs = recentJobs.map(job => {
      const content = job.aiContent as any;
      return {
        id: job.id,
        title: job.title,
        cityName: job.cityName,
        status: job.status,
        qualityScore: content?.qualityScore || null,
        quality108: content?.quality108 || null,
        writerUsed: content?.writerUsed || null,
        generatedAt: content?.generatedAt || null,
        processingTimeMs: content?.processingTimeMs || null,
      };
    });

    res.json({ jobs });
  } catch (error) {
    log.error("[Octypo] Failed to get recent jobs", error);
    res.status(500).json({ error: "Failed to retrieve jobs" });
  }
});

/**
 * GET /api/octypo/jobs/:jobId
 * Returns status of a specific job
 */
router.get("/jobs/:jobId", async (req: Request, res: Response) => {
  try {
    const jobId = Number.parseInt(req.params.jobId, 10);
    if (Number.isNaN(jobId)) {
      return res.status(400).json({ error: "Invalid job ID" });
    }

    const [job] = await db
      .select({
        id: tiqetsAttractions.id,
        title: tiqetsAttractions.title,
        cityName: tiqetsAttractions.cityName,
        status: tiqetsAttractions.contentGenerationStatus,
        aiContent: tiqetsAttractions.aiContent,
      })
      .from(tiqetsAttractions)
      .where(eq(tiqetsAttractions.id, jobId as any))
      .limit(1);

    if (!job) {
      return res.status(404).json({ error: "Job not found" });
    }

    const content = job.aiContent as any;
    res.json({
      id: job.id,
      title: job.title,
      cityName: job.cityName,
      status: job.status,
      qualityScore: content?.qualityScore || null,
      quality108: content?.quality108 || null,
      writerUsed: content?.writerUsed || null,
      generatedAt: content?.generatedAt || null,
      processingTimeMs: content?.processingTimeMs || null,
      content: content?.content || null,
    });
  } catch (error) {
    log.error("[Octypo] Failed to get job", error);
    res.status(500).json({ error: "Failed to retrieve job" });
  }
});

/**
 * GET /api/octypo/queue-status
 * Returns status of the background job queue
 */
router.get("/queue-status", async (_req: Request, res: Response) => {
  try {
    const stats = await jobQueue.getStats();
    const pendingJobs = await jobQueue.getJobsByStatus("pending");
    const processingJobs = await jobQueue.getJobsByStatus("processing");

    res.json({
      stats,
      pendingJobs: pendingJobs.slice(0, 20).map(j => ({
        id: j.id,
        type: j.type,
        status: j.status,
        createdAt: j.createdAt,
        data: j.data,
      })),
      processingJobs: processingJobs.map(j => ({
        id: j.id,
        type: j.type,
        status: j.status,
        startedAt: j.startedAt,
        data: j.data,
      })),
    });
  } catch (error) {
    log.error("[Octypo] Failed to get queue status", error);
    res.status(500).json({ error: "Failed to retrieve queue status" });
  }
});

// ============================================================================
// AUTOPILOT CONFIG (in-memory state for config options)
// ============================================================================

interface AutopilotConfig {
  autoExplodeContent: boolean;
  autoTranslate: boolean;
  autoFetchImages: boolean;
  autoPublish: boolean;
  rssIngestion: boolean;
  googleDriveSync: boolean;
}

let autopilotConfig: AutopilotConfig = {
  autoExplodeContent: true,
  autoTranslate: true,
  autoFetchImages: true,
  autoPublish: false,
  rssIngestion: true,
  googleDriveSync: false,
};

// ============================================================================
// DESTINATIONS ENDPOINTS - REAL DATA
// ============================================================================

/**
 * GET /api/octypo/destinations
 * Returns list of destinations with health metrics from real database
 */
router.get("/destinations", async (_req: Request, res: Response) => {
  try {
    const destinationStats = await db.execute(sql`
      SELECT 
        city_name,
        COUNT(*)::int as total_attractions,
        COUNT(CASE WHEN ai_content IS NOT NULL THEN 1 END)::int as with_content,
        COALESCE(AVG(CASE WHEN ai_content IS NOT NULL THEN (ai_content->>'qualityScore')::numeric END), 0)::numeric(5,2) as avg_quality,
        MAX(CASE WHEN ai_content IS NOT NULL THEN ai_content->>'generatedAt' END) as last_updated
      FROM tiqets_attractions
      WHERE city_name IS NOT NULL AND city_name != ''
      GROUP BY city_name
      ORDER BY total_attractions DESC
      LIMIT 50
    `);

    const destinations = (destinationStats.rows as any[]).map(row => {
      const total = row.total_attractions || 0;
      const withContent = row.with_content || 0;
      const health = total > 0 ? Math.round((withContent / total) * 100) : 0;
      const coverage = total > 0 ? Math.round((withContent / total) * 100) : 0;

      let status = "Initializing";
      if (health >= 90) status = "Running";
      else if (health >= 50) status = "Growing";
      else if (health >= 20) status = "Initializing";
      else status = "New";

      return {
        id: row.city_name.toLowerCase().replace(/\s+/g, "-"),
        name: row.city_name,
        health,
        status,
        coverage,
        budgetToday: 0,
        budgetLimit: 50,
        alerts: health < 50 ? Math.floor((100 - health) / 20) : 0,
        contentCount: withContent,
        totalAttractions: total,
        avgQuality: Number.parseFloat(row.avg_quality) || 0,
        lastUpdated: row.last_updated || null,
      };
    });

    res.json({ destinations });
  } catch (error) {
    log.error("[Octypo] Failed to get destinations", error);
    res.status(500).json({ error: "Failed to retrieve destinations" });
  }
});

// ============================================================================
// AUTOPILOT ENDPOINTS - REAL STATE
// ============================================================================

/**
 * GET /api/octypo/autopilot/status
 * Returns autopilot status using real OctypoRunState
 */
router.get("/autopilot/status", async (_req: Request, res: Response) => {
  try {
    const isRunning = octypoState.isRunning();
    const lastCompleted = octypoState.getLastCompleted();
    const lastActivity = octypoState.getLastActivity();
    const stateStats = octypoState.getStats();

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const todayIso = today.toISOString().split("T")[0];

    const todayStats = await db.execute(sql`
      SELECT 
        COUNT(CASE WHEN ai_content->>'generatedAt' >= ${todayIso} THEN 1 END)::int as content_generated_today,
        COUNT(CASE WHEN content_generation_status = 'failed' AND ai_content->>'generatedAt' >= ${todayIso} THEN 1 END)::int as errors_today
      FROM tiqets_attractions
      WHERE ai_content IS NOT NULL
    `);

    const statsRow = (todayStats.rows[0] as any) || {};

    const status = {
      running: isRunning,
      mode: "full" as const,
      startedAt: lastActivity?.toISOString() || null,
      lastCompleted: lastCompleted?.toISOString() || null,
      stats: {
        contentGeneratedToday: statsRow.content_generated_today || 0,
        translationsToday: 0,
        publishedToday: 0,
        tasksCompletedToday: statsRow.content_generated_today || 0,
        imagesProcessedToday: 0,
        errorsToday: statsRow.errors_today || stateStats.failedCount,
        failedQueueSize: stateStats.failedCount,
        successRate: Math.round(stateStats.successRate * 100),
        concurrency: stateStats.concurrency,
      },
      uptime: lastActivity ? Math.floor((Date.now() - lastActivity.getTime()) / 1000) : 0,
    };

    res.json(status);
  } catch (error) {
    log.error("[Octypo] Failed to get autopilot status", error);
    res.status(500).json({ error: "Failed to retrieve autopilot status" });
  }
});

/**
 * POST /api/octypo/autopilot/start
 * Start the autopilot
 */
router.post("/autopilot/start", async (req: Request, res: Response) => {
  try {
    const { mode = "full" } = req.body;

    octypoState.setRunning(true);

    log.info(`[Octypo] Autopilot started in ${mode} mode`);

    res.json({
      success: true,
      message: `Autopilot started in ${mode} mode`,
      state: {
        running: true,
        mode,
        startedAt: new Date().toISOString(),
      },
    });
  } catch (error) {
    log.error("[Octypo] Failed to start autopilot", error);
    res.status(500).json({ error: "Failed to start autopilot" });
  }
});

/**
 * POST /api/octypo/autopilot/stop
 * Stop the autopilot
 */
router.post("/autopilot/stop", async (_req: Request, res: Response) => {
  try {
    octypoState.setRunning(false);

    log.info("[Octypo] Autopilot stopped");

    res.json({
      success: true,
      message: "Autopilot stopped",
      state: {
        running: false,
        mode: "full",
        startedAt: null,
      },
    });
  } catch (error) {
    log.error("[Octypo] Failed to stop autopilot", error);
    res.status(500).json({ error: "Failed to stop autopilot" });
  }
});

/**
 * GET /api/octypo/autopilot/config
 * Returns autopilot configuration
 */
router.get("/autopilot/config", async (_req: Request, res: Response) => {
  try {
    res.json(autopilotConfig);
  } catch (error) {
    log.error("[Octypo] Failed to get autopilot config", error);
    res.status(500).json({ error: "Failed to retrieve autopilot config" });
  }
});

/**
 * PATCH /api/octypo/autopilot/config
 * Update autopilot configuration
 */
router.patch("/autopilot/config", async (req: Request, res: Response) => {
  try {
    const updates = req.body;

    const validKeys: (keyof AutopilotConfig)[] = [
      "autoExplodeContent",
      "autoTranslate",
      "autoFetchImages",
      "autoPublish",
      "rssIngestion",
      "googleDriveSync",
    ];

    for (const key of validKeys) {
      if (typeof updates[key] === "boolean") {
        autopilotConfig[key] = updates[key];
      }
    }

    log.info("[Octypo] Autopilot config updated", updates);

    res.json({
      success: true,
      config: autopilotConfig,
    });
  } catch (error) {
    log.error("[Octypo] Failed to update autopilot config", error);
    res.status(500).json({ error: "Failed to update autopilot config" });
  }
});

/**
 * GET /api/octypo/autopilot/pipeline
 * Returns pipeline status based on real queue state
 */
router.get("/autopilot/pipeline", async (_req: Request, res: Response) => {
  try {
    const queueStats = await db.execute(sql`
      SELECT 
        COUNT(CASE WHEN ai_content IS NULL THEN 1 END)::int as pending,
        COUNT(CASE WHEN ai_content IS NOT NULL THEN 1 END)::int as processed,
        COUNT(CASE WHEN content_generation_status = 'failed' THEN 1 END)::int as failed
      FROM tiqets_attractions
    `);

    const stats = (queueStats.rows[0] as any) || {};
    const failedQueue = octypoState.getFailedQueue();

    const pipeline = [
      {
        id: "content-generation",
        name: "Content Generation",
        status: octypoState.isRunning() ? "running" : "idle",
        itemsProcessed: stats.processed || 0,
        itemsPending: stats.pending || 0,
        lastRun: octypoState.getLastActivity()?.toISOString() || null,
        avgProcessingTime: 45,
        errorRate: stats.processed > 0 ? (stats.failed / stats.processed) * 100 : 0,
      },
      {
        id: "failed-retry",
        name: "Failed Retry Queue",
        status: failedQueue.length > 0 ? "pending" : "idle",
        itemsProcessed: 0,
        itemsPending: failedQueue.length,
        lastRun: null,
        avgProcessingTime: 0,
        errorRate: 0,
      },
    ];

    res.json({ pipeline });
  } catch (error) {
    log.error("[Octypo] Failed to get pipeline status", error);
    res.status(500).json({ error: "Failed to retrieve pipeline status" });
  }
});

/**
 * GET /api/octypo/autopilot/tasks
 * Returns active tasks from the failed queue
 */
router.get("/autopilot/tasks", async (_req: Request, res: Response) => {
  try {
    const failedQueue = octypoState.getFailedQueue();

    const tasks = failedQueue.map((item, idx) => ({
      id: `task-${item.id}`,
      title: item.title,
      type: "content-generation",
      progress: 0,
      status: "pending",
      retryCount: item.retryCount,
      lastError: item.lastError,
      failedAt: item.failedAt.toISOString(),
    }));

    res.json({
      tasks,
      summary: {
        running: 0,
        pending: tasks.length,
        completed: 0,
      },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get tasks", error);
    res.status(500).json({ error: "Failed to retrieve tasks" });
  }
});

// ============================================================================
// CONTENT ENDPOINTS - REAL DATA
// ============================================================================

/**
 * GET /api/octypo/content
 * Returns content list from real contents table
 */
router.get("/content", async (req: Request, res: Response) => {
  try {
    const limit = Math.min(Number.parseInt(req.query.limit as string) || 50, 100);
    const offset = Number.parseInt(req.query.offset as string) || 0;
    const statusFilter = req.query.status as string;
    const typeFilter = req.query.type as string;

    let whereConditions: any[] = [];

    if (statusFilter) {
      whereConditions.push(eq(contents.status, statusFilter as any));
    }
    if (typeFilter) {
      whereConditions.push(eq(contents.type, typeFilter as any));
    }

    const whereClause = whereConditions.length > 0 ? and(...whereConditions) : undefined;

    const [contentItems, countResult] = await Promise.all([
      db
        .select({
          id: contents.id,
          title: contents.title,
          type: contents.type,
          status: contents.status,
          seoScore: contents.seoScore,
          wordCount: contents.wordCount,
          writerId: contents.writerId,
          publishedAt: contents.publishedAt,
          updatedAt: contents.updatedAt,
          createdAt: contents.createdAt,
        })
        .from(contents)
        .where(whereClause)
        .orderBy(desc(contents.updatedAt))
        .limit(limit)
        .offset(offset),

      db
        .select({ count: sql<number>`count(*)::int` })
        .from(contents)
        .where(whereClause)
        .then(r => r[0]?.count ?? 0),
    ]);

    const formattedContent = contentItems.map(item => ({
      id: item.id,
      title: item.title,
      type: item.type,
      status: item.status,
      seoScore: item.seoScore || 0,
      wordCount: item.wordCount || 0,
      writerId: item.writerId,
      publishedAt: item.publishedAt?.toISOString() || null,
      updatedAt: item.updatedAt?.toISOString() || null,
      createdAt: item.createdAt?.toISOString() || null,
    }));

    res.json({
      content: formattedContent,
      total: countResult,
      limit,
      offset,
    });
  } catch (error) {
    log.error("[Octypo] Failed to get content", error);
    res.status(500).json({ error: "Failed to retrieve content" });
  }
});

// ============================================================================
// REVIEW QUEUE ENDPOINTS - REAL DATA
// ============================================================================

/**
 * GET /api/octypo/review-queue
 * Returns items pending review from real contents table
 */
router.get("/review-queue", async (_req: Request, res: Response) => {
  try {
    const reviewItems = await db
      .select({
        id: contents.id,
        title: contents.title,
        type: contents.type,
        status: contents.status,
        seoScore: contents.seoScore,
        wordCount: contents.wordCount,
        writerId: contents.writerId,
        createdAt: contents.createdAt,
        updatedAt: contents.updatedAt,
      })
      .from(contents)
      .where(eq(contents.status, "in_review"))
      .orderBy(desc(contents.createdAt))
      .limit(100);

    const formattedItems = reviewItems.map(item => ({
      id: item.id,
      contentId: item.id,
      title: item.title,
      type: item.type,
      priority: item.seoScore && item.seoScore < 70 ? "high" : "medium",
      createdAt: item.createdAt?.toISOString() || null,
      quality: item.seoScore || 0,
      seo: item.seoScore || 0,
      issues: [],
      writerId: item.writerId,
      wordCount: item.wordCount || 0,
    }));

    const byPriority = {
      high: formattedItems.filter(r => r.priority === "high").length,
      medium: formattedItems.filter(r => r.priority === "medium").length,
      low: formattedItems.filter(r => r.priority === "low").length,
    };

    res.json({
      queue: formattedItems,
      total: formattedItems.length,
      byPriority,
    });
  } catch (error) {
    log.error("[Octypo] Failed to get review queue", error);
    res.status(500).json({ error: "Failed to retrieve review queue" });
  }
});

/**
 * POST /api/octypo/review-queue/:id/approve
 * Approve a review item - updates real content status
 */
router.post("/review-queue/:id/approve", async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { notes, publishImmediately = false } = req.body;

    const newStatus = publishImmediately ? "published" : "approved";

    await db
      .update(contents)
      .set({
        status: newStatus,
        approvedAt: new Date(),
        publishedAt: publishImmediately ? new Date() : undefined,
        updatedAt: new Date(),
      } as any)
      .where(eq(contents.id, id));

    log.info(`[Octypo] Review item ${id} approved`, { notes, publishImmediately });

    res.json({
      success: true,
      message: `Review item ${id} approved`,
      action: publishImmediately ? "Published" : "Approved",
      reviewedAt: new Date().toISOString(),
    });
  } catch (error) {
    log.error("[Octypo] Failed to approve review item", error);
    res.status(500).json({ error: "Failed to approve review item" });
  }
});

/**
 * POST /api/octypo/review-queue/:id/reject
 * Reject a review item - updates real content status
 */
router.post("/review-queue/:id/reject", async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { reason, sendBackToWriter = true } = req.body;

    const newStatus = sendBackToWriter ? "draft" : "archived";

    await db
      .update(contents)
      .set({
        status: newStatus,
        updatedAt: new Date(),
      } as any)
      .where(eq(contents.id, id));

    log.info(`[Octypo] Review item ${id} rejected`, { reason, sendBackToWriter });

    res.json({
      success: true,
      message: `Review item ${id} rejected`,
      action: sendBackToWriter ? "Sent back to writer" : "Archived",
      reviewedAt: new Date().toISOString(),
    });
  } catch (error) {
    log.error("[Octypo] Failed to reject review item", error);
    res.status(500).json({ error: "Failed to reject review item" });
  }
});

// ============================================================================
// AGENT ENDPOINTS (DETAILED) - REAL DATA
// ============================================================================

/**
 * GET /api/octypo/agents/writers/detailed
 * Returns writers with full personality info and real stats from database
 */
router.get("/agents/writers/detailed", async (_req: Request, res: Response) => {
  try {
    ensureInitialized();

    const writers = AgentRegistry.getAllWriters();

    const writerStatsResult = await db.execute(sql`
      SELECT 
        ai_content->>'writerUsed' as writer_id,
        COUNT(*)::int as generated,
        COUNT(CASE WHEN content_generation_status = 'completed' THEN 1 END)::int as successful,
        COALESCE(AVG((ai_content->>'qualityScore')::numeric), 0)::numeric(5,2) as avg_quality,
        COALESCE(AVG((ai_content->>'processingTimeMs')::numeric), 0)::numeric(10,0) as avg_time
      FROM tiqets_attractions
      WHERE ai_content IS NOT NULL AND ai_content->>'writerUsed' IS NOT NULL
      GROUP BY ai_content->>'writerUsed'
    `);

    const statsMap = new Map<string, any>();
    for (const row of writerStatsResult.rows as any[]) {
      statsMap.set(row.writer_id, row);
    }

    const writerDetails = writers.map(writer => {
      const persona = (writer as any).persona || {};
      const stats = statsMap.get(writer.id) || {
        generated: 0,
        successful: 0,
        avg_quality: 0,
        avg_time: 0,
      };
      const successRate = stats.generated > 0 ? (stats.successful / stats.generated) * 100 : 0;

      return {
        id: writer.id,
        name: writer.name,
        specialty: writer.specialty,
        experienceYears: 10,
        languagesCount: 3,
        traits: persona.tone ? [persona.tone] : [],
        quote: "",
        avatar: null,
        stats: {
          generated: Number.parseInt(stats.generated) || 0,
          successRate: Math.round(successRate * 10) / 10,
          avgQuality: Number.parseFloat(stats.avg_quality) || 0,
          avgSEO: 0,
          avgWordCount: 0,
          avgProcessingTimeMs: Number.parseInt(stats.avg_time) || 0,
        },
        expertise: persona.expertise || [],
        tone: persona.tone || "",
        preferredDestinations: [],
      };
    });

    res.json({ writers: writerDetails });
  } catch (error) {
    log.error("[Octypo] Failed to get detailed writers", error);
    res.status(500).json({ error: "Failed to retrieve detailed writers" });
  }
});

/**
 * GET /api/octypo/agents/stats
 * Returns aggregate agent performance stats from real database
 */
router.get("/agents/stats", async (_req: Request, res: Response) => {
  try {
    ensureInitialized();

    const [overallStats, writerStats, recentStats] = await Promise.all([
      db
        .execute(
          sql`
        SELECT 
          COUNT(*)::int as total_generated,
          COUNT(CASE WHEN content_generation_status = 'completed' THEN 1 END)::int as successful,
          COALESCE(AVG((ai_content->>'qualityScore')::numeric), 0)::numeric(5,2) as avg_quality,
          COALESCE(AVG((ai_content->>'processingTimeMs')::numeric), 0)::numeric(10,0) as avg_time
        FROM tiqets_attractions
        WHERE ai_content IS NOT NULL
      `
        )
        .then(r => r.rows[0] as any),

      db
        .execute(
          sql`
        SELECT 
          ai_content->>'writerUsed' as writer_id,
          COUNT(*)::int as generated,
          COUNT(CASE WHEN content_generation_status = 'completed' THEN 1 END)::int as successful,
          COALESCE(AVG((ai_content->>'qualityScore')::numeric), 0)::numeric(5,2) as avg_quality
        FROM tiqets_attractions
        WHERE ai_content IS NOT NULL AND ai_content->>'writerUsed' IS NOT NULL
        GROUP BY ai_content->>'writerUsed'
        ORDER BY generated DESC
      `
        )
        .then(r => r.rows as any[]),

      db
        .execute(
          sql`
        SELECT 
          COUNT(CASE WHEN ai_content->>'generatedAt' >= NOW() - INTERVAL '7 days' THEN 1 END)::int as last_7_days,
          COUNT(CASE WHEN ai_content->>'generatedAt' >= NOW() - INTERVAL '30 days' THEN 1 END)::int as last_30_days,
          COALESCE(AVG(CASE WHEN ai_content->>'generatedAt' >= NOW() - INTERVAL '7 days' THEN (ai_content->>'qualityScore')::numeric END), 0)::numeric(5,2) as quality_7_days,
          COALESCE(AVG(CASE WHEN ai_content->>'generatedAt' >= NOW() - INTERVAL '30 days' THEN (ai_content->>'qualityScore')::numeric END), 0)::numeric(5,2) as quality_30_days
        FROM tiqets_attractions
        WHERE ai_content IS NOT NULL
      `
        )
        .then(r => r.rows[0] as any),
    ]);

    const writers = AgentRegistry.getAllWriters();
    const writerNameMap = new Map(writers.map(w => [w.id, w.name]));

    const totalGenerated = Number.parseInt(overallStats.total_generated) || 0;
    const successRate =
      totalGenerated > 0 ? (Number.parseInt(overallStats.successful) / totalGenerated) * 100 : 0;

    const byWriter = writerStats.map(row => {
      const generated = Number.parseInt(row.generated) || 0;
      const successful = Number.parseInt(row.successful) || 0;
      return {
        id: row.writer_id,
        name: writerNameMap.get(row.writer_id) || row.writer_id,
        generated,
        successRate: generated > 0 ? Math.round((successful / generated) * 1000) / 10 : 0,
        avgQuality: Number.parseFloat(row.avg_quality) || 0,
        avgSEO: 0,
      };
    });

    const topByQuality =
      byWriter.length > 0 ? byWriter.reduce((a, b) => (a.avgQuality > b.avgQuality ? a : b)) : null;
    const topByVolume =
      byWriter.length > 0 ? byWriter.reduce((a, b) => (a.generated > b.generated ? a : b)) : null;
    const topBySuccessRate =
      byWriter.length > 0
        ? byWriter.reduce((a, b) => (a.successRate > b.successRate ? a : b))
        : null;

    const stats = {
      overall: {
        totalGenerated,
        avgSuccessRate: Math.round(successRate * 10) / 10,
        avgQuality: Number.parseFloat(overallStats.avg_quality) || 0,
        avgSEO: 0,
        avgProcessingTime: Number.parseFloat(overallStats.avg_time) || 0,
      },
      byWriter,
      topPerformers: {
        byQuality: topByQuality
          ? { id: topByQuality.id, name: topByQuality.name, score: topByQuality.avgQuality }
          : null,
        bySEO: null,
        byVolume: topByVolume
          ? { id: topByVolume.id, name: topByVolume.name, count: topByVolume.generated }
          : null,
        bySuccessRate: topBySuccessRate
          ? {
              id: topBySuccessRate.id,
              name: topBySuccessRate.name,
              rate: topBySuccessRate.successRate,
            }
          : null,
      },
      trends: {
        last7Days: {
          generated: Number.parseInt(recentStats.last_7_days) || 0,
          avgQuality: Number.parseFloat(recentStats.quality_7_days) || 0,
        },
        last30Days: {
          generated: Number.parseInt(recentStats.last_30_days) || 0,
          avgQuality: Number.parseFloat(recentStats.quality_30_days) || 0,
        },
      },
    };

    res.json(stats);
  } catch (error) {
    log.error("[Octypo] Failed to get agent stats", error);
    res.status(500).json({ error: "Failed to retrieve agent stats" });
  }
});

// ============================================================================
// WORKFLOW ENDPOINTS - REAL DATA
// ============================================================================

/**
 * GET /api/octypo/workflows
 * Returns workflow list from real workflow_instances table
 */
router.get("/workflows", async (_req: Request, res: Response) => {
  try {
    const workflowData = await db
      .select({
        id: workflowInstances.id,
        contentId: workflowInstances.contentId,
        status: workflowInstances.status,
        currentStep: workflowInstances.currentStep,
        submittedAt: workflowInstances.submittedAt,
        completedAt: workflowInstances.completedAt,
        metadata: workflowInstances.metadata,
        contentTitle: contents.title,
        contentType: contents.type,
        writerId: contents.writerId,
      })
      .from(workflowInstances)
      .leftJoin(contents, eq(workflowInstances.contentId, contents.id))
      .orderBy(desc(workflowInstances.submittedAt))
      .limit(100);

    const workflows = workflowData.map(wf => {
      const steps = ["draft", "review", "translation", "images", "seo-check", "published"];
      const completedSteps = wf.currentStep || 0;
      const duration =
        wf.submittedAt && wf.completedAt
          ? wf.completedAt.getTime() - wf.submittedAt.getTime()
          : null;

      return {
        id: wf.id,
        contentTitle: wf.contentTitle || "Untitled",
        contentId: wf.contentId,
        status: wf.status || "pending",
        currentStep: steps[Math.min(completedSteps, steps.length - 1)],
        steps,
        completedSteps,
        totalSteps: steps.length,
        startedAt: wf.submittedAt?.toISOString() || null,
        completedAt: wf.completedAt?.toISOString() || null,
        duration,
        writerId: wf.writerId,
      };
    });

    const summary = {
      completed: workflows.filter(
        w => (w.status as string) === "completed" || w.status === "approved"
      ).length,
      running: workflows.filter(w => w.status === "in_progress" || w.status === "pending").length,
      pending: workflows.filter(w => w.status === "pending").length,
      avgCompletionTime:
        workflows.filter(w => w.duration).reduce((sum, w) => sum + (w.duration || 0), 0) /
        (workflows.filter(w => w.duration).length || 1),
    };

    res.json({
      workflows,
      summary,
    });
  } catch (error) {
    log.error("[Octypo] Failed to get workflows", error);
    res.status(500).json({ error: "Failed to retrieve workflows" });
  }
});

/**
 * GET /api/octypo/engines
 * Returns all AI engines with their status
 */
router.get("/engines", async (_req: Request, res: Response) => {
  try {
    EngineRegistry.initialize();
    const engines = EngineRegistry.getAllEngines();
    const stats = EngineRegistry.getStats();

    const engineList = engines.map(engine => ({
      id: engine.id,
      name: engine.name,
      provider: engine.provider,
      model: engine.model,
      isHealthy: engine.isHealthy,
      errorCount: engine.errorCount,
      successCount: engine.successCount,
      lastError: engine.lastError || null,
      lastUsed: engine.lastUsed?.toISOString() || null,
    }));

    res.json({
      engines: engineList,
      stats: {
        total: stats.total,
        healthy: stats.healthy,
        unhealthy: stats.total - stats.healthy,
        byProvider: stats.byProvider,
      },
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get engines", error);
    res.status(500).json({ error: "Failed to retrieve engines" });
  }
});

/**
 * GET /api/octypo/engines/stats
 * Returns aggregate engine statistics
 */
router.get("/engines/stats", async (_req: Request, res: Response) => {
  try {
    EngineRegistry.initialize();
    const engines = EngineRegistry.getAllEngines();
    const stats = EngineRegistry.getStats();

    const totalRequests = engines.reduce((sum, e) => sum + e.successCount + e.errorCount, 0);
    const totalSuccess = engines.reduce((sum, e) => sum + e.successCount, 0);
    const successRate =
      totalRequests > 0 ? ((totalSuccess / totalRequests) * 100).toFixed(1) : "100.0";

    res.json({
      total: stats.total,
      healthy: stats.healthy,
      unhealthy: stats.total - stats.healthy,
      byProvider: stats.byProvider,
      performance: {
        totalRequests,
        successfulRequests: totalSuccess,
        failedRequests: totalRequests - totalSuccess,
        successRate: Number.parseFloat(successRate),
      },
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get engine stats", error);
    res.status(500).json({ error: "Failed to retrieve engine stats" });
  }
});

/**
 * GET /api/octypo/ai-queue/status
 * Returns AI request queue status with rate limiting info
 */
router.get("/ai-queue/status", async (_req: Request, res: Response) => {
  try {
    const queueStats = getQueueStats();

    res.json({
      queue: {
        length: queueStats.queueLength,
        processing: queueStats.processing,
        activeRequests: queueStats.activeRequests,
        completedRequests: queueStats.completedRequests,
        failedRequests: queueStats.failedRequests,
      },
      providers: queueStats.providers.map(p => ({
        name: p.name,
        available: p.available,
        tokens: p.tokens,
        maxTokens: p.maxTokens,
        requestsThisMinute: p.requestsThisMinute,
        requestsThisHour: p.requestsThisHour,
        blockedUntil: p.blockedUntil,
        waitTimeSeconds: p.waitTimeSeconds,
        status: p.status,
      })),
      estimatedWait: queueStats.estimatedWait,
      estimatedWaitSeconds: queueStats.estimatedWaitSeconds,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get AI queue status", error);
    res.status(500).json({ error: "Failed to retrieve AI queue status" });
  }
});

/**
 * GET /api/octypo/job-queue/status
 * Returns background job queue status from PostgreSQL
 */
router.get("/job-queue/status", async (_req: Request, res: Response) => {
  try {
    const stats = await jobQueue.getStats();
    const recentJobs = await jobQueue.getRecentJobs(20);

    res.json({
      stats,
      recentJobs: recentJobs.map(job => ({
        id: job.id,
        type: job.type,
        status: job.status,
        priority: job.priority,
        retries: job.retries,
        maxRetries: job.maxRetries,
        error: job.error || null,
        createdAt: job.createdAt.toISOString(),
        startedAt: job.startedAt?.toISOString() || null,
        completedAt: job.completedAt?.toISOString() || null,
      })),
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get job queue status", error);
    res.status(500).json({ error: "Failed to retrieve job queue status" });
  }
});

// ============================================================================
// CONTENT JOB CREATION
// ============================================================================

interface ContentJobConfig {
  destination?: string;
  sourceType: "rss" | "topic" | "manual";
  rssFeedIds?: string[];
  topicKeywords?: string[];
  manualContent?: { title: string; description: string }[];
  quantity?: number;
  priority?: "low" | "normal" | "high";
}

/**
 * POST /api/octypo/jobs/create
 * Create a new content generation job
 */
router.post("/jobs/create", async (req: Request, res: Response) => {
  try {
    ensureInitialized();

    const config: ContentJobConfig = req.body;

    if (!config.sourceType) {
      return res.status(400).json({ error: "Source type is required" });
    }

    const priority = config.priority === "high" ? 10 : config.priority === "low" ? 1 : 5;
    const createdJobs: { id: string; type: string; destination?: string }[] = [];

    if (config.sourceType === "rss") {
      if (!config.rssFeedIds || config.rssFeedIds.length === 0) {
        return res.status(400).json({ error: "At least one RSS feed is required" });
      }

      const { rssFeeds } = await import("@shared/schema");
      const { inArray } = await import("drizzle-orm");

      const feeds = await db.select().from(rssFeeds).where(inArray(rssFeeds.id, config.rssFeedIds));

      for (const feed of feeds) {
        const jobId = await jobQueue.addJob(
          "ai_generate" as any,
          {
            jobType: "rss-content-generation",
            feedId: feed.id,
            feedUrl: feed.url,
            feedName: feed.name,
            destination: config.destination || feed.destinationId,
            category: feed.category,
          },
          { priority }
        );

        createdJobs.push({
          id: jobId,
          type: "rss-content-generation",
          destination: config.destination || feed.destinationId || undefined,
        });
      }

      log.info(`[Octypo] Created ${createdJobs.length} RSS content jobs`);
    } else if (config.sourceType === "topic") {
      if (!config.topicKeywords || config.topicKeywords.length === 0) {
        return res.status(400).json({ error: "At least one topic keyword is required" });
      }

      const quantity = Math.min(config.quantity || 5, 20);

      const jobId = await jobQueue.addJob(
        "ai_generate" as any,
        {
          jobType: "topic-content-generation",
          keywords: config.topicKeywords,
          destination: config.destination,
          quantity,
        },
        { priority }
      );

      createdJobs.push({
        id: jobId,
        type: "topic-content-generation",
        destination: config.destination,
      });

      log.info(
        `[Octypo] Created topic content job for keywords: ${config.topicKeywords.join(", ")}`
      );
    } else if (config.sourceType === "manual") {
      if (!config.manualContent || config.manualContent.length === 0) {
        return res.status(400).json({ error: "Manual content items required" });
      }

      for (const item of config.manualContent) {
        const jobId = await jobQueue.addJob(
          "ai_generate" as any,
          {
            jobType: "manual-content-generation",
            title: item.title,
            description: item.description,
            destination: config.destination,
          },
          { priority }
        );

        createdJobs.push({
          id: jobId,
          type: "manual-content-generation",
          destination: config.destination,
        });
      }

      log.info(`[Octypo] Created ${createdJobs.length} manual content jobs`);
    }

    res.json({
      success: true,
      jobsCreated: createdJobs.length,
      jobs: createdJobs,
      message: `Created ${createdJobs.length} content generation job(s)`,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to create content job", error);
    res.status(500).json({
      error: "Failed to create content job",
      message: error instanceof Error ? error.message : "Unknown error",
    });
  }
});

/**
 * GET /api/octypo/sources/rss
 * Get available RSS feeds for content generation
 */
router.get("/sources/rss", async (req: Request, res: Response) => {
  try {
    const { rssFeeds, destinations } = await import("@shared/schema");
    const { eq, isNull } = await import("drizzle-orm");

    const destinationId = req.query.destination as string | undefined;

    let feeds;
    if (destinationId) {
      feeds = await db
        .select({
          id: rssFeeds.id,
          name: rssFeeds.name,
          url: rssFeeds.url,
          category: rssFeeds.category,
          isActive: rssFeeds.isActive,
          destinationId: rssFeeds.destinationId,
          language: rssFeeds.language,
        })
        .from(rssFeeds)
        .where(eq(rssFeeds.destinationId, destinationId));
    } else {
      feeds = await db
        .select({
          id: rssFeeds.id,
          name: rssFeeds.name,
          url: rssFeeds.url,
          category: rssFeeds.category,
          isActive: rssFeeds.isActive,
          destinationId: rssFeeds.destinationId,
          language: rssFeeds.language,
        })
        .from(rssFeeds);
    }

    const allDestinations = await db
      .select({
        id: destinations.id,
        name: destinations.name,
      })
      .from(destinations);

    const destMap = new Map(allDestinations.map(d => [d.id, d.name]));

    res.json({
      feeds: feeds.map(f => ({
        ...f,
        destinationName: f.destinationId ? destMap.get(f.destinationId) : null,
      })),
      totalCount: feeds.length,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get RSS sources", error);
    res.status(500).json({ error: "Failed to retrieve RSS sources" });
  }
});

/**
 * GET /api/octypo/sources/destinations
 * Get list of destinations for job creation
 */
router.get("/sources/destinations", async (_req: Request, res: Response) => {
  try {
    const { destinations } = await import("@shared/schema");

    const allDests = await db
      .select({
        id: destinations.id,
        name: destinations.name,
        country: destinations.country,
        destinationLevel: destinations.destinationLevel,
      })
      .from(destinations);

    const feedCounts = await db.execute(sql`
      SELECT destination_id, COUNT(*)::int as feed_count 
      FROM rss_feeds 
      WHERE destination_id IS NOT NULL 
      GROUP BY destination_id
    `);

    const feedCountMap = new Map(
      (feedCounts.rows as any[]).map(r => [r.destination_id, r.feed_count])
    );

    res.json({
      destinations: allDests.map(d => ({
        ...d,
        rssFeedCount: feedCountMap.get(d.id) || 0,
      })),
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get destinations", error);
    res.status(500).json({ error: "Failed to retrieve destinations" });
  }
});

/**
 * POST /api/octypo/jobs/:jobId/process
 * DEPRECATED: Pipeline A manual processing removed. Use Gatekeeper pipeline.
 */
router.post("/jobs/:jobId/process", async (_req: Request, res: Response) => {
  res.status(410).json({
    error: "Deprecated: Pipeline A job processing removed. Use POST /api/gatekeeper/run instead.",
    _meta: { apiVersion: "v1" },
  });
});

/**
 * GET /api/octypo/rss-scheduler/status
 * Get RSS scheduler status and configuration
 */
router.get("/rss-scheduler/status", async (_req: Request, res: Response) => {
  try {
    const status = getRSSSchedulerStatus();
    res.json({
      ...status,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get RSS scheduler status", error);
    res.status(500).json({ error: "Failed to get scheduler status" });
  }
});

/**
 * POST /api/octypo/rss-scheduler/start
 * Start the RSS scheduler with optional config
 */
router.post("/rss-scheduler/start", async (req: Request, res: Response) => {
  try {
    const { dailyLimit, intervalMinutes } = req.body || {};

    const config: Record<string, number | boolean> = { enabled: true };
    if (dailyLimit !== undefined) config.dailyLimit = dailyLimit;
    if (intervalMinutes !== undefined) config.intervalMinutes = intervalMinutes;

    startRSSScheduler(config);

    const status = getRSSSchedulerStatus();
    res.json({
      message: "RSS scheduler started",
      ...status,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to start RSS scheduler", error);
    res.status(500).json({ error: "Failed to start scheduler" });
  }
});

/**
 * POST /api/octypo/rss-scheduler/stop
 * Stop the RSS scheduler
 */
router.post("/rss-scheduler/stop", async (_req: Request, res: Response) => {
  try {
    stopRSSScheduler();
    res.json({
      message: "RSS scheduler stopped",
      running: false,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to stop RSS scheduler", error);
    res.status(500).json({ error: "Failed to stop scheduler" });
  }
});

/**
 * POST /api/octypo/rss-scheduler/config
 * Update RSS scheduler configuration
 */
router.post("/rss-scheduler/config", async (req: Request, res: Response) => {
  try {
    const { dailyLimit, intervalMinutes, enabled } = req.body || {};

    const config: Record<string, number | boolean> = {};
    if (dailyLimit !== undefined) config.dailyLimit = dailyLimit;
    if (intervalMinutes !== undefined) config.intervalMinutes = intervalMinutes;
    if (enabled !== undefined) config.enabled = enabled;

    updateRSSSchedulerConfig(config);

    const status = getRSSSchedulerStatus();
    res.json({
      message: "RSS scheduler config updated",
      ...status,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to update RSS scheduler config", error);
    res.status(500).json({ error: "Failed to update config" });
  }
});

/**
 * POST /api/octypo/rss-scheduler/trigger
 * Manually trigger RSS scheduler cycle
 */
router.post("/rss-scheduler/trigger", async (_req: Request, res: Response) => {
  try {
    log.info("[Octypo] Manual RSS scheduler trigger requested");
    const result = await triggerRSSScheduler();
    res.json({
      message: "RSS scheduler cycle triggered",
      created: result.created,
      destinations: result.destinations,
      globalRemaining: result.globalRemaining,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to trigger RSS scheduler", error);
    res.status(500).json({ error: "Failed to trigger scheduler" });
  }
});

/**
 * GET /api/octypo/rss-scheduler/stats
 * Get detailed scheduler statistics per destination
 */
router.get("/rss-scheduler/stats", async (_req: Request, res: Response) => {
  try {
    const stats = await getSchedulerStats();
    const status = getRSSSchedulerStatus();

    res.json({
      running: status.running,
      config: status.config,
      stats: {
        totalToday: stats.totalToday,
        globalRemaining: stats.globalRemaining,
        perDestination: stats.perDestination,
        perDestinationRemaining: stats.perDestinationRemaining,
      },
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get RSS scheduler stats", error);
    res.status(500).json({ error: "Failed to get scheduler stats" });
  }
});

// ============================================================================
// RSS READER ENDPOINTS (NEW - WITH PROPER PARSING)
// ============================================================================

/**
 * GET /api/octypo/rss/stats
 * Get RSS reader statistics
 */
router.get("/rss/stats", async (_req: Request, res: Response) => {
  try {
    const stats = await rssReader.getStats();
    res.json({
      ...stats,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get RSS stats", error);
    res.status(500).json({ error: "Failed to get RSS stats" });
  }
});

/**
 * POST /api/octypo/rss/fetch/:feedId
 * Fetch and store items from a specific RSS feed
 */
router.post("/rss/fetch/:feedId", async (req: Request, res: Response) => {
  try {
    const { feedId } = req.params;

    if (!feedId) {
      return res.status(400).json({ error: "Feed ID is required" });
    }

    log.info(`[Octypo] Fetching RSS feed: ${feedId}`);
    const result = await rssReader.fetchFeed(feedId);

    res.json({
      ...result,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to fetch RSS feed", error);
    res.status(500).json({ error: "Failed to fetch RSS feed" });
  }
});

/**
 * POST /api/octypo/rss/fetch-all
 * Fetch and store items from all active RSS feeds
 */
router.post("/rss/fetch-all", async (_req: Request, res: Response) => {
  try {
    log.info("[Octypo] Fetching all RSS feeds");
    const results = await rssReader.fetchAllFeeds();

    const summary = {
      feedsProcessed: results.length,
      totalItemsFetched: results.reduce((sum, r) => sum + r.itemsFetched, 0),
      newItems: results.reduce((sum, r) => sum + r.newItems, 0),
      duplicatesSkipped: results.reduce((sum, r) => sum + r.duplicatesSkipped, 0),
      feedsWithErrors: results.filter(r => r.errors.length > 0).length,
    };

    res.json({
      summary,
      results,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to fetch all RSS feeds", error);
    res.status(500).json({ error: "Failed to fetch all feeds" });
  }
});

/**
 * GET /api/octypo/rss/items/unprocessed
 * Get unprocessed RSS feed items ready for content generation
 */
router.get("/rss/items/unprocessed", async (req: Request, res: Response) => {
  try {
    const limit = Math.min(Number.parseInt(req.query.limit as string) || 20, 100);
    const feedId = req.query.feedId as string | undefined;

    const items = await rssReader.getUnprocessedItems(limit, feedId);

    res.json({
      items,
      count: items.length,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get unprocessed items", error);
    res.status(500).json({ error: "Failed to get unprocessed items" });
  }
});

/**
 * GET /api/octypo/rss/items/recent
 * Get recent RSS feed items
 */
router.get("/rss/items/recent", async (req: Request, res: Response) => {
  try {
    const limit = Math.min(Number.parseInt(req.query.limit as string) || 20, 100);
    const sinceHours = Number.parseInt(req.query.sinceHours as string) || undefined;

    let sinceDate: Date | undefined;
    if (sinceHours) {
      sinceDate = new Date(Date.now() - sinceHours * 60 * 60 * 1000);
    }

    const items = await rssReader.getRecentItems(limit, sinceDate);

    res.json({
      items,
      count: items.length,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get recent items", error);
    res.status(500).json({ error: "Failed to get recent items" });
  }
});

/**
 * POST /api/octypo/rss/items/:itemId/mark-processed
 * Mark an RSS item as processed
 */
router.post("/rss/items/:itemId/mark-processed", async (req: Request, res: Response) => {
  try {
    const { itemId } = req.params;
    const { contentId } = req.body;

    if (!itemId) {
      return res.status(400).json({ error: "Item ID is required" });
    }

    await rssReader.markProcessed(itemId, contentId);

    res.json({
      success: true,
      message: "Item marked as processed",
      itemId,
      contentId,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to mark item as processed", error);
    res.status(500).json({ error: "Failed to mark item as processed" });
  }
});

/**
 * POST /api/octypo/rss/generate-from-items
 * Generate content from unprocessed RSS items with locale support
 */
router.post("/rss/generate-from-items", async (req: Request, res: Response) => {
  try {
    const { limit = 5, feedId, locale = "en", destinationId } = req.body;
    const itemLimit = Math.min(limit, 20);

    log.info(`[Octypo] Generating content from RSS items`, { limit: itemLimit, feedId, locale });

    // Get unprocessed items
    const items = await rssReader.getUnprocessedItems(itemLimit, feedId);

    if (items.length === 0) {
      return res.json({
        success: true,
        message: "No unprocessed items found",
        generated: 0,
        _meta: { apiVersion: "v1" },
      });
    }

    // Create jobs for each item
    const createdJobs: string[] = [];

    for (const item of items) {
      const jobId = await jobQueue.addJob(
        "ai_generate" as any,
        {
          jobType: "rss-content-generation",
          feedId: item.feedId,
          feedUrl: "",
          feedName: item.source,
          destination: destinationId || undefined,
          category: item.category,
          locale: locale as "en" | "ar",
        },
        { priority: 5 }
      );

      createdJobs.push(jobId);
    }

    res.json({
      success: true,
      message: `Created ${createdJobs.length} content generation jobs`,
      itemsFound: items.length,
      jobsCreated: createdJobs.length,
      jobs: createdJobs,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to generate from RSS items", error);
    res.status(500).json({ error: "Failed to generate from RSS items" });
  }
});

// ============================================================================
// CONTENT EXPLODER ENDPOINTS
// ============================================================================

import { getExplosionOrchestrator } from "../../octypo/exploder";
import { getEntityExtractor } from "../../octypo/exploder/entity-extractor";
import { contentEntities, explosionJobs, explodedArticles } from "@shared/schema";

/**
 * POST /api/octypo/exploder/entities/extract/:contentId
 * Extract entities from content for explosion
 */
router.post("/exploder/entities/extract/:contentId", async (req: Request, res: Response) => {
  try {
    const { contentId } = req.params;

    if (!contentId) {
      return res.status(400).json({ error: "Content ID is required" });
    }

    log.info(`[Octypo] Extracting entities from content: ${contentId}`);

    const extractor = getEntityExtractor();
    const result = await extractor.extractFromContent(contentId);

    if (result.success) {
      res.json({
        success: true,
        contentId,
        entitiesExtracted: result.entities.length,
        entities: result.entities,
        extractionTimeMs: result.extractionTimeMs,
        _meta: { apiVersion: "v1" },
      });
    } else {
      res.status(400).json({
        success: false,
        contentId,
        error: result.error,
        extractionTimeMs: result.extractionTimeMs,
        _meta: { apiVersion: "v1" },
      });
    }
  } catch (error) {
    log.error("[Octypo] Entity extraction failed", error);
    res.status(500).json({
      error: "Entity extraction failed",
      message: error instanceof Error ? error.message : "Unknown error",
    });
  }
});

/**
 * POST /api/octypo/exploder/jobs
 * Start a content explosion job
 */
router.post("/exploder/jobs", async (req: Request, res: Response) => {
  try {
    const { contentId, config } = req.body;

    if (!contentId) {
      return res.status(400).json({ error: "Content ID is required" });
    }

    log.info(`[Octypo] Starting explosion job for content: ${contentId}`);

    const orchestrator = getExplosionOrchestrator();
    const jobId = await orchestrator.startExplosion(contentId, config || {});

    res.json({
      success: true,
      jobId,
      contentId,
      message: "Explosion job started",
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to start explosion job", error);
    res.status(500).json({
      error: "Failed to start explosion job",
      message: error instanceof Error ? error.message : "Unknown error",
    });
  }
});

/**
 * GET /api/octypo/exploder/jobs/:id
 * Get explosion job progress
 */
router.get("/exploder/jobs/:id", async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    const orchestrator = getExplosionOrchestrator();
    const progress = await orchestrator.getJobProgress(id);

    if (!progress) {
      return res.status(404).json({ error: "Job not found" });
    }

    res.json({
      jobId: id,
      ...progress,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get explosion job", error);
    res.status(500).json({ error: "Failed to get job progress" });
  }
});

/**
 * POST /api/octypo/exploder/jobs/:id/cancel
 * Cancel an explosion job
 */
router.post("/exploder/jobs/:id/cancel", async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    const orchestrator = getExplosionOrchestrator();
    const cancelled = await orchestrator.cancelJob(id);

    if (cancelled) {
      res.json({
        success: true,
        jobId: id,
        message: "Job cancelled",
        _meta: { apiVersion: "v1" },
      });
    } else {
      res.status(400).json({
        success: false,
        jobId: id,
        error: "Job cannot be cancelled (already completed or not found)",
        _meta: { apiVersion: "v1" },
      });
    }
  } catch (error) {
    log.error("[Octypo] Failed to cancel explosion job", error);
    res.status(500).json({ error: "Failed to cancel job" });
  }
});

/**
 * GET /api/octypo/exploder/stats
 * Get explosion statistics
 */
router.get("/exploder/stats", async (_req: Request, res: Response) => {
  try {
    const [jobStats, entityStats, articleStats] = await Promise.all([
      db
        .execute(
          sql`
        SELECT
          COUNT(*)::int as total_jobs,
          COUNT(CASE WHEN status = 'completed' THEN 1 END)::int as completed,
          COUNT(CASE WHEN status = 'failed' THEN 1 END)::int as failed,
          COUNT(CASE WHEN status IN ('pending', 'extracting', 'ideating', 'generating') THEN 1 END)::int as running,
          SUM(entities_extracted)::int as total_entities,
          SUM(ideas_generated)::int as total_ideas,
          SUM(articles_generated)::int as total_articles
        FROM explosion_jobs
      `
        )
        .then(r => r.rows[0] as any),

      db
        .execute(
          sql`
        SELECT
          COUNT(*)::int as total_entities,
          COUNT(CASE WHEN verified = true THEN 1 END)::int as verified,
          COUNT(DISTINCT entity_type)::int as unique_types
        FROM content_entities
        WHERE merged_into_id IS NULL
      `
        )
        .then(r => r.rows[0] as any),

      db
        .execute(
          sql`
        SELECT
          COUNT(*)::int as total_articles,
          COUNT(CASE WHEN status = 'generated' THEN 1 END)::int as generated,
          COUNT(CASE WHEN status = 'published' THEN 1 END)::int as published,
          COALESCE(AVG(quality_108_score), 0)::numeric(5,2) as avg_quality
        FROM exploded_articles
      `
        )
        .then(r => r.rows[0] as any),
    ]);

    res.json({
      jobs: {
        total: jobStats?.total_jobs || 0,
        completed: jobStats?.completed || 0,
        failed: jobStats?.failed || 0,
        running: jobStats?.running || 0,
      },
      entities: {
        total: entityStats?.total_entities || 0,
        verified: entityStats?.verified || 0,
        uniqueTypes: entityStats?.unique_types || 0,
      },
      articles: {
        total: articleStats?.total_articles || 0,
        generated: articleStats?.generated || 0,
        published: articleStats?.published || 0,
        avgQuality: Number.parseFloat(articleStats?.avg_quality) || 0,
      },
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get exploder stats", error);
    res.status(500).json({ error: "Failed to get exploder stats" });
  }
});

/**
 * GET /api/octypo/exploder/entities
 * List extracted entities with pagination
 */
router.get("/exploder/entities", async (req: Request, res: Response) => {
  try {
    const limit = Math.min(Number.parseInt(req.query.limit as string) || 50, 200);
    const offset = Number.parseInt(req.query.offset as string) || 0;
    const entityType = req.query.type as string | undefined;

    let whereClause;
    if (entityType) {
      whereClause = and(
        sql`merged_into_id IS NULL`,
        eq(contentEntities.entityType, entityType as any)
      );
    } else {
      whereClause = sql`merged_into_id IS NULL`;
    }

    const [entities, countResult] = await Promise.all([
      db
        .select()
        .from(contentEntities)
        .where(whereClause)
        .orderBy(desc(contentEntities.createdAt))
        .limit(limit)
        .offset(offset),

      db
        .select({ count: sql<number>`count(*)::int` })
        .from(contentEntities)
        .where(whereClause)
        .then(r => r[0]?.count ?? 0),
    ]);

    res.json({
      entities,
      total: countResult,
      limit,
      offset,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get entities", error);
    res.status(500).json({ error: "Failed to get entities" });
  }
});

// ============================================================================
// REAL AUTOPILOT ENDPOINTS (4-MODE SYSTEM)
// ============================================================================

import { autopilotAPI, getRealAutopilot, getAutopilotScheduler } from "../../octypo/pilot";
import { autopilotTasks, autopilotSchedules } from "@shared/schema";

/**
 * GET /api/octypo/real-autopilot/status
 * Get full autopilot status
 */
router.get("/real-autopilot/status", async (_req: Request, res: Response) => {
  try {
    const status = await autopilotAPI.getStatus();
    res.json({
      ...status,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get real autopilot status", error);
    res.status(500).json({ error: "Failed to get autopilot status" });
  }
});

/**
 * POST /api/octypo/real-autopilot/mode
 * Set autopilot mode
 */
router.post("/real-autopilot/mode", async (req: Request, res: Response) => {
  try {
    const { mode } = req.body;
    const userId = (req as any).user?.id || "system";

    if (!["off", "monitor", "semi_auto", "full_auto"].includes(mode)) {
      return res
        .status(400)
        .json({ error: "Invalid mode. Must be: off, monitor, semi_auto, or full_auto" });
    }

    log.info(`[Octypo] Setting real autopilot mode to: ${mode} by ${userId}`);

    const state = await autopilotAPI.setMode(mode, userId);

    res.json({
      success: true,
      mode,
      state,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to set autopilot mode", error);
    res.status(500).json({ error: "Failed to set autopilot mode" });
  }
});

/**
 * GET /api/octypo/real-autopilot/tasks
 * Get autopilot tasks with optional status filter
 */
router.get("/real-autopilot/tasks", async (req: Request, res: Response) => {
  try {
    const status = req.query.status as string | undefined;
    const limit = Math.min(Number.parseInt(req.query.limit as string) || 50, 200);
    const offset = Number.parseInt(req.query.offset as string) || 0;

    const autopilot = getRealAutopilot();
    const tasks = await autopilot.getTasks(status as any, limit, offset);

    const [countResult] = await db
      .select({ count: sql<number>`count(*)::int` })
      .from(autopilotTasks)
      .where(status ? eq(autopilotTasks.status, status as any) : undefined);

    res.json({
      tasks,
      total: countResult?.count || 0,
      limit,
      offset,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get autopilot tasks", error);
    res.status(500).json({ error: "Failed to get tasks" });
  }
});

/**
 * GET /api/octypo/real-autopilot/tasks/awaiting-approval
 * Get tasks awaiting approval
 */
router.get("/real-autopilot/tasks/awaiting-approval", async (req: Request, res: Response) => {
  try {
    const limit = Math.min(Number.parseInt(req.query.limit as string) || 50, 200);
    const tasks = await autopilotAPI.getAwaitingApproval(limit);

    res.json({
      tasks,
      count: tasks.length,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get tasks awaiting approval", error);
    res.status(500).json({ error: "Failed to get tasks" });
  }
});

/**
 * POST /api/octypo/real-autopilot/tasks/:id/approve
 * Approve a task
 */
router.post("/real-autopilot/tasks/:id/approve", async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const userId = (req as any).user?.id || "system";

    const success = await autopilotAPI.processApproval(id, "approve", userId);

    if (success) {
      res.json({
        success: true,
        taskId: id,
        action: "approved",
        approvedBy: userId,
        _meta: { apiVersion: "v1" },
      });
    } else {
      res.status(400).json({
        success: false,
        error: "Task cannot be approved (not awaiting approval or not found)",
        _meta: { apiVersion: "v1" },
      });
    }
  } catch (error) {
    log.error("[Octypo] Failed to approve task", error);
    res.status(500).json({ error: "Failed to approve task" });
  }
});

/**
 * POST /api/octypo/real-autopilot/tasks/:id/reject
 * Reject a task
 */
router.post("/real-autopilot/tasks/:id/reject", async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { reason } = req.body;
    const userId = (req as any).user?.id || "system";

    const success = await autopilotAPI.processApproval(id, "reject", userId, reason);

    if (success) {
      res.json({
        success: true,
        taskId: id,
        action: "rejected",
        rejectedBy: userId,
        reason,
        _meta: { apiVersion: "v1" },
      });
    } else {
      res.status(400).json({
        success: false,
        error: "Task cannot be rejected (not awaiting approval or not found)",
        _meta: { apiVersion: "v1" },
      });
    }
  } catch (error) {
    log.error("[Octypo] Failed to reject task", error);
    res.status(500).json({ error: "Failed to reject task" });
  }
});

/**
 * POST /api/octypo/real-autopilot/run-now
 * Trigger immediate processing
 */
router.post("/real-autopilot/run-now", async (req: Request, res: Response) => {
  try {
    const { taskTypes } = req.body;

    log.info("[Octypo] Manual run-now triggered", { taskTypes });

    const result = await autopilotAPI.runNow(taskTypes);

    res.json({
      success: true,
      ...result,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to run autopilot", error);
    res.status(500).json({ error: "Failed to run autopilot" });
  }
});

/**
 * POST /api/octypo/real-autopilot/tasks
 * Create a new task
 */
router.post("/real-autopilot/tasks", async (req: Request, res: Response) => {
  try {
    const { taskType, title, description, config, priority, scheduledFor } = req.body;

    if (!taskType || !title) {
      return res.status(400).json({ error: "taskType and title are required" });
    }

    const autopilot = getRealAutopilot();
    const taskId = await autopilot.createTask(taskType, title, config || {}, {
      description,
      priority,
      scheduledFor: scheduledFor ? new Date(scheduledFor) : undefined,
    });

    res.json({
      success: true,
      taskId,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to create task", error);
    res.status(500).json({ error: "Failed to create task" });
  }
});

/**
 * GET /api/octypo/real-autopilot/schedules
 * Get all schedules
 */
router.get("/real-autopilot/schedules", async (_req: Request, res: Response) => {
  try {
    const schedules = await autopilotAPI.getSchedules();

    res.json({
      schedules,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to get schedules", error);
    res.status(500).json({ error: "Failed to get schedules" });
  }
});

/**
 * PATCH /api/octypo/real-autopilot/schedules/:id
 * Update a schedule
 */
router.patch("/real-autopilot/schedules/:id", async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const { enabled, cronExpression, config } = req.body;

    await autopilotAPI.updateSchedule(id, { enabled, cronExpression });

    res.json({
      success: true,
      scheduleId: id,
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to update schedule", error);
    res.status(500).json({ error: "Failed to update schedule" });
  }
});

/**
 * POST /api/octypo/real-autopilot/schedules/:id/trigger
 * Trigger a schedule immediately
 */
router.post("/real-autopilot/schedules/:id/trigger", async (req: Request, res: Response) => {
  try {
    const { id } = req.params;

    const scheduler = getAutopilotScheduler();
    await scheduler.triggerSchedule(id);

    res.json({
      success: true,
      scheduleId: id,
      message: "Schedule triggered",
      _meta: { apiVersion: "v1" },
    });
  } catch (error) {
    log.error("[Octypo] Failed to trigger schedule", error);
    res.status(500).json({ error: "Failed to trigger schedule" });
  }
});

export default router;
