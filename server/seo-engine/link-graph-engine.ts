/**
 * Link Graph Engine - Graph-Based Internal Linking Intelligence
 *
 * Features:
 * - Build and analyze link graph structure
 * - Calculate PageRank-style link equity
 * - Identify link clusters and silos
 * - Detect broken link paths
 * - Optimize link flow for SEO priority pages
 */

import { db } from '../db';
import { contents, internalLinks } from '../../shared/schema';
import { eq, and, or, ne, desc, sql, count } from 'drizzle-orm';
import { PageClassifier, PageClassification } from './page-classifier';

export interface LinkNode {
  id: string;
  title: string;
  type: string;
  classification: PageClassification;
  url: string;
  inboundCount: number;
  outboundCount: number;
  pageRank: number;
  cluster?: string;
  isOrphan: boolean;
  isDeadEnd: boolean;
  depth: number;
}

export interface LinkEdge {
  sourceId: string;
  targetId: string;
  anchorText: string;
  weight: number;
  isAutoGenerated: boolean;
}

export interface LinkGraph {
  nodes: Map<string, LinkNode>;
  edges: LinkEdge[];
  orphans: string[];
  deadEnds: string[];
  clusters: Map<string, string[]>;
  avgDepth: number;
  maxDepth: number;
}

export interface LinkFlowAnalysis {
  pageId: string;
  pageRank: number;
  inboundEquity: number;
  outboundEquity: number;
  equityFlow: 'positive' | 'negative' | 'neutral';
  topInboundSources: { id: string; title: string; equity: number }[];
  topOutboundTargets: { id: string; title: string; equity: number }[];
  recommendations: string[];
}

export interface LinkOptimization {
  action: 'add' | 'remove' | 'update';
  sourceId: string;
  targetId: string;
  reason: string;
  expectedImpact: 'HIGH' | 'MEDIUM' | 'LOW';
  suggestedAnchor?: string;
}

// Link weight by page classification
const CLASSIFICATION_LINK_WEIGHT: Record<PageClassification, number> = {
  MONEY_PAGE: 1.5,
  GUIDE: 2.0,
  INFORMATIONAL: 1.0,
  EVERGREEN: 1.0,
  NEWS: 0.5,
  EXPERIMENTAL: 0.3,
  SEO_RISK: 0.0,
};

export class LinkGraphEngine {
  private classifier: PageClassifier;
  private graph: LinkGraph | null = null;
  private lastBuildTime: Date | null = null;

  constructor() {
    this.classifier = new PageClassifier();
  }

  /**
   * Build the complete link graph
   */
  async buildGraph(): Promise<LinkGraph> {
    const allContent = await db.query.contents.findMany({
      where: eq(contents.status, 'published'),
    });

    const allLinks = await db.query.internalLinks.findMany();

    const nodes = new Map<string, LinkNode>();
    const edges: LinkEdge[] = [];
    const orphans: string[] = [];
    const deadEnds: string[] = [];
    const clusters = new Map<string, string[]>();

    // Create nodes
    for (const content of allContent) {
      const classification = await this.classifier.classifyContent(content.id);

      const inboundCount = allLinks.filter((l) => l.targetContentId === content.id).length;
      const outboundCount = allLinks.filter((l) => l.sourceContentId === content.id).length;

      nodes.set(content.id, {
        id: content.id,
        title: content.title,
        type: content.type,
        classification: classification.classification,
        url: content.slug || `/${content.type}/${content.id}`,
        inboundCount,
        outboundCount,
        pageRank: 1.0, // Initial PageRank
        isOrphan: inboundCount === 0,
        isDeadEnd: outboundCount === 0,
        depth: 0,
      });

      if (inboundCount === 0) orphans.push(content.id);
      if (outboundCount === 0) deadEnds.push(content.id);
    }

    // Create edges with weights
    for (const link of allLinks) {
      if (!link.sourceContentId || !link.targetContentId) continue;

      const targetNode = nodes.get(link.targetContentId as any);
      const weight = targetNode
        ? CLASSIFICATION_LINK_WEIGHT[targetNode.classification]
        : 1.0;

      edges.push({
        sourceId: link.sourceContentId as any,
        targetId: link.targetContentId as any,
        anchorText: (link.anchorText as any) || '',
        weight,
        isAutoGenerated: (link.isAutoSuggested as any) || false,
      });
    }

    // Calculate PageRank
    this.calculatePageRank(nodes, edges);

    // Calculate depth from home/main pages
    this.calculateDepth(nodes, edges);

    // Identify clusters
    this.identifyClusters(nodes, edges, clusters);

    // Calculate average and max depth
    const depths = Array.from(nodes.values()).map((n) => n.depth);
    const avgDepth = depths.reduce((a, b) => a + b, 0) / depths.length || 0;
    const maxDepth = Math.max(...depths, 0);

    this.graph = { nodes, edges, orphans, deadEnds, clusters, avgDepth, maxDepth };
    this.lastBuildTime = new Date();

    return this.graph;
  }

  /**
   * Calculate PageRank-style scores
   */
  private calculatePageRank(
    nodes: Map<string, LinkNode>,
    edges: LinkEdge[],
    iterations: number = 20,
    dampingFactor: number = 0.85
  ): void {
    const n = nodes.size;
    if (n === 0) return;

    // Build adjacency list
    const outLinks = new Map<string, string[]>();
    for (const edge of edges) {
      if (!outLinks.has(edge.sourceId)) {
        outLinks.set(edge.sourceId, []);
      }
      outLinks.get(edge.sourceId)!.push(edge.targetId);
    }

    // Iterate PageRank calculation
    for (let i = 0; i < iterations; i++) {
      const newRanks = new Map<string, number>();

      for (const [id, node] of nodes) {
        let rank = (1 - dampingFactor) / n;

        // Sum contributions from inbound links
        for (const edge of edges) {
          if (edge.targetId === id) {
            const sourceNode = nodes.get(edge.sourceId);
            if (sourceNode) {
              const outCount = outLinks.get(edge.sourceId)?.length || 1;
              rank += dampingFactor * (sourceNode.pageRank / outCount) * edge.weight;
            }
          }
        }

        newRanks.set(id, rank);
      }

      // Update ranks
      for (const [id, rank] of newRanks) {
        const node = nodes.get(id);
        if (node) node.pageRank = rank;
      }
    }
  }

  /**
   * Calculate depth from entry points
   */
  private calculateDepth(nodes: Map<string, LinkNode>, edges: LinkEdge[]): void {
    // Find entry points (highest PageRank or MONEY_PAGE classification)
    const entryPoints = Array.from(nodes.values())
      .filter((n) => n.classification === 'MONEY_PAGE' || n.classification === 'GUIDE')
      .sort((a, b) => b.pageRank - a.pageRank)
      .slice(0, 5)
      .map((n) => n.id);

    if (entryPoints.length === 0) {
      // Use highest PageRank pages as entry points
      const sorted = Array.from(nodes.values()).sort((a, b) => b.pageRank - a.pageRank);
      if (sorted.length > 0) entryPoints.push(sorted[0].id);
    }

    // BFS to calculate depth
    const visited = new Set<string>();
    const queue: { id: string; depth: number }[] = entryPoints.map((id) => ({ id, depth: 0 }));

    while (queue.length > 0) {
      const { id, depth } = queue.shift()!;

      if (visited.has(id)) continue;
      visited.add(id);

      const node = nodes.get(id);
      if (node) node.depth = depth;

      // Find outbound links
      for (const edge of edges) {
        if (edge.sourceId === id && !visited.has(edge.targetId)) {
          queue.push({ id: edge.targetId, depth: depth + 1 });
        }
      }
    }

    // Set depth for unreachable nodes
    for (const [id, node] of nodes) {
      if (!visited.has(id)) {
        node.depth = -1; // Unreachable
      }
    }
  }

  /**
   * Identify link clusters/silos
   */
  private identifyClusters(
    nodes: Map<string, LinkNode>,
    edges: LinkEdge[],
    clusters: Map<string, string[]>
  ): void {
    // Group by content type as initial clusters
    for (const [id, node] of nodes) {
      const clusterName = node.type || 'other';
      if (!clusters.has(clusterName)) {
        clusters.set(clusterName, []);
      }
      clusters.get(clusterName)!.push(id);
      node.cluster = clusterName;
    }
  }

  /**
   * Analyze link flow for a specific page
   */
  async analyzeLinkFlow(contentId: string): Promise<LinkFlowAnalysis> {
    if (!this.graph) {
      await this.buildGraph();
    }

    const node = this.graph!.nodes.get(contentId);
    if (!node) {
      throw new Error(`Content not found in graph: ${contentId}`);
    }

    // Get inbound links with equity
    const inboundEdges = this.graph!.edges.filter((e) => e.targetId === contentId);
    const topInboundSources = inboundEdges
      .map((e) => {
        const sourceNode = this.graph!.nodes.get(e.sourceId);
        return {
          id: e.sourceId,
          title: sourceNode?.title || 'Unknown',
          equity: (sourceNode?.pageRank || 0) * e.weight,
        };
      })
      .sort((a, b) => b.equity - a.equity)
      .slice(0, 5);

    // Get outbound links with equity
    const outboundEdges = this.graph!.edges.filter((e) => e.sourceId === contentId);
    const topOutboundTargets = outboundEdges
      .map((e) => {
        const targetNode = this.graph!.nodes.get(e.targetId);
        return {
          id: e.targetId,
          title: targetNode?.title || 'Unknown',
          equity: (node.pageRank / (outboundEdges.length || 1)) * e.weight,
        };
      })
      .sort((a, b) => b.equity - a.equity)
      .slice(0, 5);

    // Calculate equity flow
    const inboundEquity = topInboundSources.reduce((sum, s) => sum + s.equity, 0);
    const outboundEquity = topOutboundTargets.reduce((sum, t) => sum + t.equity, 0);
    const equityFlow: 'positive' | 'negative' | 'neutral' =
      inboundEquity > outboundEquity * 1.2 ? 'positive' :
      outboundEquity > inboundEquity * 1.2 ? 'negative' : 'neutral';

    // Generate recommendations
    const recommendations: string[] = [];

    if (node.isOrphan) {
      recommendations.push('CRITICAL: Page is orphan (no inbound links). Add links from related content.');
    }

    if (node.isDeadEnd) {
      recommendations.push('Add outbound links to related content to distribute link equity.');
    }

    if (node.depth > 3) {
      recommendations.push(`Page is too deep (${node.depth} clicks from entry). Add links from higher-level pages.`);
    }

    if (node.classification === 'MONEY_PAGE' && inboundEdges.length < 5) {
      recommendations.push('MONEY_PAGE should have more inbound links. Currently has ' + inboundEdges.length);
    }

    if (equityFlow === 'negative' && node.classification === 'MONEY_PAGE') {
      recommendations.push('MONEY_PAGE is losing link equity. Reduce outbound links or increase inbound.');
    }

    return {
      pageId: contentId,
      pageRank: node.pageRank,
      inboundEquity,
      outboundEquity,
      equityFlow,
      topInboundSources,
      topOutboundTargets,
      recommendations,
    };
  }

  /**
   * Get optimization suggestions for the entire site
   */
  async getOptimizations(): Promise<LinkOptimization[]> {
    if (!this.graph) {
      await this.buildGraph();
    }

    const optimizations: LinkOptimization[] = [];

    // 1. Fix orphan pages - suggest links from related content
    for (const orphanId of this.graph!.orphans) {
      const orphanNode = this.graph!.nodes.get(orphanId);
      if (!orphanNode) continue;

      // Find related content in same cluster
      const clusterMembers = this.graph!.clusters.get(orphanNode.cluster || '') || [];
      const potentialSources = clusterMembers
        .filter((id) => id !== orphanId)
        .map((id) => this.graph!.nodes.get(id))
        .filter((n) => n && !n.isDeadEnd && n.pageRank > 0)
        .sort((a, b) => (b?.pageRank || 0) - (a?.pageRank || 0))
        .slice(0, 3);

      for (const source of potentialSources) {
        if (source) {
          optimizations.push({
            action: 'add',
            sourceId: source.id,
            targetId: orphanId,
            reason: `Fix orphan page: "${orphanNode.title}"`,
            expectedImpact: 'HIGH',
            suggestedAnchor: orphanNode.title,
          });
        }
      }
    }

    // 2. Boost MONEY_PAGEs with insufficient links
    const moneyPages = Array.from(this.graph!.nodes.values()).filter(
      (n) => n.classification === 'MONEY_PAGE' && n.inboundCount < 5
    );

    for (const moneyPage of moneyPages) {
      // Find high-PageRank pages that could link to this
      const potentialSources = Array.from(this.graph!.nodes.values())
        .filter(
          (n) =>
            n.id !== moneyPage.id &&
            n.classification !== 'SEO_RISK' &&
            n.pageRank > moneyPage.pageRank &&
            !this.graph!.edges.some((e) => e.sourceId === n.id && e.targetId === moneyPage.id)
        )
        .sort((a, b) => b.pageRank - a.pageRank)
        .slice(0, 3);

      for (const source of potentialSources) {
        optimizations.push({
          action: 'add',
          sourceId: source.id,
          targetId: moneyPage.id,
          reason: `Boost MONEY_PAGE: "${moneyPage.title}" (currently ${moneyPage.inboundCount} inbound links)`,
          expectedImpact: 'HIGH',
          suggestedAnchor: moneyPage.title,
        });
      }
    }

    // 3. Reduce depth for deep pages
    const deepPages = Array.from(this.graph!.nodes.values()).filter(
      (n) => n.depth > 3 && n.classification !== 'SEO_RISK'
    );

    for (const deepPage of deepPages) {
      // Find high-level pages that could link directly
      const potentialSources = Array.from(this.graph!.nodes.values())
        .filter(
          (n) =>
            n.id !== deepPage.id &&
            n.depth < 2 &&
            !this.graph!.edges.some((e) => e.sourceId === n.id && e.targetId === deepPage.id)
        )
        .sort((a, b) => b.pageRank - a.pageRank)
        .slice(0, 2);

      for (const source of potentialSources) {
        optimizations.push({
          action: 'add',
          sourceId: source.id,
          targetId: deepPage.id,
          reason: `Reduce depth for "${deepPage.title}" (currently ${deepPage.depth} clicks deep)`,
          expectedImpact: 'MEDIUM',
          suggestedAnchor: deepPage.title,
        });
      }
    }

    // 4. Remove links to SEO_RISK pages
    const riskLinks = this.graph!.edges.filter((e) => {
      const targetNode = this.graph!.nodes.get(e.targetId);
      return targetNode?.classification === 'SEO_RISK';
    });

    for (const link of riskLinks) {
      const targetNode = this.graph!.nodes.get(link.targetId);
      optimizations.push({
        action: 'remove',
        sourceId: link.sourceId,
        targetId: link.targetId,
        reason: `Remove link to SEO_RISK content: "${targetNode?.title}"`,
        expectedImpact: 'HIGH',
      });
    }

    return optimizations.sort((a, b) => {
      const impactOrder = { HIGH: 0, MEDIUM: 1, LOW: 2 };
      return impactOrder[a.expectedImpact] - impactOrder[b.expectedImpact];
    });
  }

  /**
   * Get graph statistics
   */
  getStats(): {
    totalNodes: number;
    totalEdges: number;
    orphanCount: number;
    deadEndCount: number;
    avgInbound: number;
    avgOutbound: number;
    avgDepth: number;
    maxDepth: number;
    clusterCount: number;
  } | null {
    if (!this.graph) return null;

    const nodes = Array.from(this.graph.nodes.values());
    const avgInbound = nodes.reduce((sum, n) => sum + n.inboundCount, 0) / nodes.length || 0;
    const avgOutbound = nodes.reduce((sum, n) => sum + n.outboundCount, 0) / nodes.length || 0;

    return {
      totalNodes: nodes.length,
      totalEdges: this.graph.edges.length,
      orphanCount: this.graph.orphans.length,
      deadEndCount: this.graph.deadEnds.length,
      avgInbound: Math.round(avgInbound * 100) / 100,
      avgOutbound: Math.round(avgOutbound * 100) / 100,
      avgDepth: Math.round(this.graph.avgDepth * 100) / 100,
      maxDepth: this.graph.maxDepth,
      clusterCount: this.graph.clusters.size,
    };
  }

  /**
   * Get top pages by PageRank
   */
  getTopPagesByRank(limit: number = 20): LinkNode[] {
    if (!this.graph) return [];

    return Array.from(this.graph.nodes.values())
      .sort((a, b) => b.pageRank - a.pageRank)
      .slice(0, limit);
  }

  /**
   * Get last build time
   */
  getLastBuildTime(): Date | null {
    return this.lastBuildTime;
  }

  /**
   * Check if graph needs rebuild (older than 1 hour)
   */
  needsRebuild(): boolean {
    if (!this.lastBuildTime) return true;
    const hourAgo = new Date(Date.now() - 60 * 60 * 1000);
    return this.lastBuildTime < hourAgo;
  }
}
